# 01. 요구사항 분석

> 요구사항을 그대로 나열하지 않고 **문제 상황 중심으로 재해석**하여 정리한다.
>
> 설계 범위: **브랜드, 상품, 좋아요, 주문** (회원 도메인은 1주차 완료 전제로 제외)
>
> **완성 기준**: 이 문서가 다음 단계(시퀀스 다이어그램)의 입력으로 충분한가?
> 요구사항은 **'무엇(What)'**에 집중하며, 기술적 세부사항(DB, API 명세)은 배제하고 유저 시나리오와 비즈니스 규칙/제약사항을 정의한다.

---

## 1. 문제 상황 재해석

### 1.1 사용자 관점

| 문제 상황 | 설명 |
|-----------|------|
| 상품 탐색의 효율성 | 사용자는 다양한 브랜드의 상품을 한 곳에서 조회하고, 브랜드별 필터링 및 정렬을 통해 원하는 상품을 빠르게 찾아야 한다 |
| 관심 상품 기록 | 마음에 드는 상품을 좋아요로 표시하고, 나중에 내가 좋아요한 상품 목록을 다시 확인할 수 있어야 한다 |
| 복수 상품 일괄 주문 | 여러 브랜드의 상품을 한 번의 주문으로 묶어 처리할 수 있어야 한다 |
| 주문 이력 확인 | 특정 기간 내 자신의 주문 내역과 상세 정보를 조회할 수 있어야 한다 |

### 1.2 비즈니스 관점

| 문제 상황 | 설명 |
|-----------|------|
| 브랜드-상품 종속성 관리 | 브랜드 삭제 시 해당 브랜드에 속한 상품이 고아(orphan) 상태가 되지 않도록 연쇄 처리가 필요하다 |
| 상품 정보 스냅샷 보존 | 주문 시점의 상품 정보(이름, 가격 등)가 변경되더라도 과거 주문 기록은 당시 정보를 유지해야 한다 |
| 재고 정합성 | 주문 시 재고 확인과 차감이 원자적으로 보장되어야 하며, 재고 부족 시 주문이 거부되어야 한다 |
| 고객/어드민 정보 분리 | 동일한 도메인이라도 고객에게 노출하는 정보와 어드민이 관리하는 정보의 범위가 다를 수 있다 |

### 1.3 시스템 관점

| 문제 상황 | 설명 |
|-----------|------|
| 좋아요 멱등성 | 동일한 사용자가 동일 상품에 좋아요를 중복 등록하는 것을 방지해야 한다 |
| 주문-재고 동시성 | 동시 주문 요청에서 재고가 음수가 되지 않도록 동시성 제어가 필요하다 |
| soft delete 정책 | 브랜드/상품 삭제 시 물리 삭제 vs 논리 삭제 전략에 따라 조회 쿼리와 데이터 정합성 전략이 달라진다 |
| 대고객/어드민 API 분리 | `/api/v1`과 `/api-admin/v1`로 접근 경로와 인증 방식이 분리되어 있으며, 권한 체계가 다르다 |

---

## 2. 유비쿼터스 언어

> 코드, 문서, 커뮤니케이션에서 동일한 용어를 사용하기 위한 정의

| 한글 | 영문 | 설명 |
|------|------|------|
| 브랜드 | Brand | 상품을 판매하는 주체. 하나의 브랜드는 여러 상품을 가진다 |
| 상품 | Product | 판매 가능한 단위. 반드시 하나의 브랜드에 속한다 |
| 좋아요 | Like | 사용자가 특정 상품에 대한 관심을 표시하는 행위 |
| 주문 | Order | 사용자가 하나 이상의 상품을 구매 요청하는 행위 |
| 주문 항목 | OrderItem | 주문 내 개별 상품 단위. 주문 시점의 상품 스냅샷을 포함한다 |
| 재고 | Stock | 상품의 판매 가능 수량 |
| 스냅샷 | Snapshot | 주문 시점에 캡처된 상품 정보(이름, 가격 등)의 사본 |

---

## 3. 도메인별 기능 요구사항

### 3.1 브랜드 (Brand)

#### 대고객 API

| 기능 | METHOD | URI | 인증 | 설명 |
|------|--------|-----|------|------|
| 브랜드 조회 | GET | `/api/v1/brands/{brandId}` | X | 단일 브랜드 정보 조회 |

**유스케이스: 브랜드 정보 조회**

```
[Main Flow]
1. 사용자가 브랜드 ID로 조회를 요청한다
2. 시스템은 해당 브랜드 정보를 반환한다

[Exception Flow]
1-a. 존재하지 않는 브랜드 ID → 404 Not Found
1-b. soft delete된 브랜드 → 404 Not Found (soft delete된 브랜드는 고객 API에서 조회 불가, 어드민 API에서만 조회 가능)
```

#### 어드민 API

| 기능 | METHOD | URI | 인증 | 설명 |
|------|--------|-----|------|------|
| 브랜드 목록 조회 | GET | `/api-admin/v1/brands?page=0&size=20` | LDAP | 등록된 브랜드 목록 (페이징) |
| 브랜드 상세 조회 | GET | `/api-admin/v1/brands/{brandId}` | LDAP | 브랜드 상세 정보 |
| 브랜드 등록 | POST | `/api-admin/v1/brands` | LDAP | 신규 브랜드 등록 |
| 브랜드 수정 | PUT | `/api-admin/v1/brands/{brandId}` | LDAP | 브랜드 정보 수정 |
| 브랜드 삭제 | DELETE | `/api-admin/v1/brands/{brandId}` | LDAP | 브랜드 삭제 (소속 상품도 함께 삭제) |

**유스케이스: 어드민 브랜드 목록 조회**

```
[Main Flow]
1. 어드민이 브랜드 목록을 요청한다 (페이징 포함)
2. 시스템은 등록된 브랜드 목록을 페이지네이션하여 반환한다

[Alternate Flow]
2-a. soft delete된 브랜드도 목록에 포함하여 관리 가능하도록 제공 (deletedAt 필드로 삭제 여부 구분)
2-b. 결과가 없는 경우 → 빈 목록 반환 (200 OK)

[고려사항]
- 어드민은 삭제된 브랜드도 조회할 수 있어야 관리(복구, 이력 확인)가 가능함
- 대고객 API와 달리 삭제 상태 필터 옵션 제공 가능
```

**유스케이스: 어드민 브랜드 상세 조회**

```
[Main Flow]
1. 어드민이 브랜드 ID로 상세 정보를 요청한다
2. 시스템은 해당 브랜드의 상세 정보(createdAt, updatedAt, deletedAt 등 관리용 필드 포함)를 반환한다

[Alternate Flow]
2-a. soft delete된 브랜드도 조회 가능 (대고객 API와 차별점)

[Exception Flow]
1-a. 존재하지 않는 브랜드 ID → 404 Not Found
```

**유스케이스: 브랜드 등록**

```
[Main Flow]
1. 어드민이 브랜드 정보(이름, 설명 등)를 입력하여 등록을 요청한다
2. 시스템은 입력 데이터의 유효성을 검증한다
3. 브랜드를 저장하고 결과를 반환한다

[Exception Flow]
2-a. 필수 필드 누락 → 400 Bad Request
2-b. 브랜드명 중복 → 409 Conflict (동일한 이름의 브랜드가 이미 존재)

[참고]
- 브랜드명 중복 검사는 spec에 명시되지 않은 자체 추가 제약사항임
- 동일 이름의 브랜드가 복수 존재하면 사용자 혼란 및 데이터 정합성 저하가 우려되어 추가함
- 추후 기획 확인을 통해 제약 유지 여부를 결정할 수 있음
```

**유스케이스: 브랜드 수정**

```
[Main Flow]
1. 어드민이 브랜드 정보 수정을 요청한다
2. 시스템은 해당 브랜드의 존재 여부를 확인한다
3. 수정 가능한 필드를 업데이트하고 결과를 반환한다

[Exception Flow]
2-a. 존재하지 않는 브랜드 ID → 404 Not Found
2-b. soft delete된 브랜드 → 404 Not Found 또는 수정 허용 (P11 결정에 따름)
2-c. 수정하려는 브랜드명이 다른 브랜드와 중복 → 409 Conflict

[참고]
- 브랜드명 중복 검사는 등록과 동일한 자체 추가 제약사항 (상단 등록 유스케이스 참고)
```

**유스케이스: 브랜드 삭제**

```
[Main Flow]
1. 어드민이 브랜드 삭제를 요청한다
2. 시스템은 해당 브랜드에 속한 모든 상품을 함께 삭제한다
3. 삭제 완료 응답을 반환한다

[Exception Flow]
1-a. 존재하지 않는 브랜드 ID → 404 Not Found
1-b. 이미 soft delete된 브랜드 → 멱등하게 성공 또는 404 Not Found (P11 결정에 따름)

[주의사항]
- 해당 브랜드의 상품에 연결된 좋아요 데이터: soft delete(deletedAt 마킹) 처리 (P7 참조)
  - 사용자 직접 취소와 달리, 시스템 연쇄 삭제이므로 복구 가능성을 보존함
- 해당 브랜드의 상품이 포함된 기존 주문의 스냅샷은 영향 없음 (스냅샷 독립)
```

---

### 3.2 상품 (Product)

#### 대고객 API

| 기능 | METHOD | URI | 인증 | 설명 |
|------|--------|-----|------|------|
| 상품 목록 조회 | GET | `/api/v1/products` | X | 상품 목록 조회 (필터링/정렬/페이징) |
| 상품 상세 조회 | GET | `/api/v1/products/{productId}` | X | 단일 상품 상세 정보 |

**상품 목록 조회 쿼리 파라미터**

| 파라미터 | 타입 | 기본값 | 설명 |
|----------|------|--------|------|
| brandId | Long | - | 특정 브랜드의 상품만 필터링 (선택) |
| sort | String | latest | 정렬 기준: `latest`, `price_asc`, `likes_desc` |
| page | Int | 0 | 페이지 번호 |
| size | Int | 20 | 페이지당 항목 수 |

**유스케이스: 상품 목록 조회**

```
[Main Flow]
1. 사용자가 상품 목록을 요청한다 (선택적으로 브랜드 필터, 정렬, 페이징 포함)
2. 시스템은 조건에 맞는 상품 목록을 페이지네이션하여 반환한다

[Alternate Flow]
2-a. brandId 파라미터가 있으면 해당 브랜드 상품만 필터링
2-b. sort 파라미터에 따라 정렬 적용
     - latest: 최신 등록순 (필수 구현)
     - price_asc: 가격 낮은 순
     - likes_desc: 좋아요 많은 순 (P12의 likeCount 비정규화 전략에 의존)

[Exception Flow]
2-c. 유효하지 않은 sort 값 → 기본값(latest) 적용 또는 400 Bad Request (P9 결정에 따름)
2-d. 결과가 없는 경우 → 빈 목록 반환 (200 OK)
```

**유스케이스: 상품 상세 조회**

```
[Main Flow]
1. 사용자가 상품 ID로 상세 정보를 요청한다
2. 시스템은 해당 상품의 상세 정보(이름, 가격, 브랜드 정보 등)를 반환한다

[Exception Flow]
1-a. 존재하지 않는 상품 ID → 404 Not Found
1-b. soft delete된 상품 → 404 Not Found (soft delete된 상품은 고객 API에서 조회 불가, 어드민 API에서만 조회 가능)
```

#### 어드민 API

| 기능 | METHOD | URI | 인증 | 설명 |
|------|--------|-----|------|------|
| 상품 목록 조회 | GET | `/api-admin/v1/products?page=0&size=20&brandId={brandId}` | LDAP | 등록된 상품 목록 (페이징) |
| 상품 상세 조회 | GET | `/api-admin/v1/products/{productId}` | LDAP | 상품 상세 정보 |
| 상품 등록 | POST | `/api-admin/v1/products` | LDAP | 신규 상품 등록 |
| 상품 수정 | PUT | `/api-admin/v1/products/{productId}` | LDAP | 상품 정보 수정 (브랜드 변경 불가) |
| 상품 삭제 | DELETE | `/api-admin/v1/products/{productId}` | LDAP | 상품 삭제 |

**어드민 상품 목록 조회 쿼리 파라미터**

| 파라미터 | 타입 | 기본값 | 설명 |
|----------|------|--------|------|
| brandId | Long | - | 특정 브랜드의 상품만 필터링 (선택) |
| page | Int | 0 | 페이지 번호 |
| size | Int | 20 | 페이지당 항목 수 |

**유스케이스: 어드민 상품 목록 조회**

```
[Main Flow]
1. 어드민이 상품 목록을 요청한다 (페이징, 브랜드 필터 포함)
2. 시스템은 등록된 상품 목록을 페이지네이션하여 반환한다

[Alternate Flow]
2-a. brandId 파라미터가 있으면 해당 브랜드 상품만 필터링
2-b. soft delete된 상품도 목록에 포함하여 관리 가능하도록 제공 (deletedAt 필드로 삭제 여부 구분)
2-c. 결과가 없는 경우 → 빈 목록 반환 (200 OK)

[고려사항]
- 어드민은 삭제된 상품도 조회할 수 있어야 관리(복구, 이력 확인)가 가능함
- 재고 수량 등 대고객 API에서 노출하지 않는 관리용 필드도 포함
```

**유스케이스: 어드민 상품 상세 조회**

```
[Main Flow]
1. 어드민이 상품 ID로 상세 정보를 요청한다
2. 시스템은 해당 상품의 상세 정보(createdAt, updatedAt, deletedAt, 재고 수량 등 관리용 필드 포함)를 반환한다

[Alternate Flow]
2-a. soft delete된 상품도 조회 가능 (대고객 API와 차별점)

[Exception Flow]
1-a. 존재하지 않는 상품 ID → 404 Not Found
```

**유스케이스: 상품 등록**

```
[Main Flow]
1. 어드민이 상품 정보를 입력하여 등록을 요청한다
2. 시스템은 브랜드 존재 여부를 확인한다
3. 상품을 저장하고 결과를 반환한다

[Exception Flow]
2-a. 존재하지 않는 브랜드 ID → 400 Bad Request
2-b. soft delete된 브랜드 ID → 400 Bad Request (삭제된 브랜드에는 상품 등록 불가)
2-c. 필수 필드 누락 → 400 Bad Request

[제약사항]
- 상품은 반드시 이미 등록되어 있고, 삭제되지 않은 활성 브랜드에 속해야 한다
```

**유스케이스: 상품 수정**

```
[Main Flow]
1. 어드민이 상품 정보 수정을 요청한다
2. 시스템은 해당 상품의 존재 여부를 확인한다
3. 시스템은 수정 가능한 필드만 업데이트한다
4. 수정 완료 응답을 반환한다

[Exception Flow]
2-a. 존재하지 않는 상품 ID → 404 Not Found
2-b. soft delete된 상품 → 404 Not Found 또는 수정 허용 (P11 결정에 따름)

[제약사항]
- 브랜드는 수정 불가 (상품 생성 시 결정된 브랜드 소속은 변경할 수 없음)
```

**유스케이스: 상품 삭제**

```
[Main Flow]
1. 어드민이 상품 삭제를 요청한다
2. 시스템은 해당 상품의 존재 여부를 확인한다
3. 상품을 삭제하고 결과를 반환한다

[Exception Flow]
2-a. 존재하지 않는 상품 ID → 404 Not Found
2-b. 이미 soft delete된 상품 → 멱등하게 성공 또는 404 Not Found (P11 결정에 따름)

[주의사항]
- 해당 상품에 연결된 좋아요 데이터: soft delete(deletedAt 마킹) 처리 (P7 참조)
  - 사용자 직접 취소와 달리, 시스템 연쇄 삭제이므로 복구 가능성을 보존함
- 해당 상품이 포함된 기존 주문의 스냅샷은 영향 없음 (스냅샷 독립)
```

---

### 3.3 좋아요 (Like)

#### 대고객 API

| 기능 | METHOD | URI | 인증 | 설명 |
|------|--------|-----|------|------|
| 좋아요 등록 | POST | `/api/v1/products/{productId}/likes` | O | 상품 좋아요 |
| 좋아요 취소 | DELETE | `/api/v1/products/{productId}/likes` | O | 상품 좋아요 취소 |
| 좋아요 목록 | GET | `/api/v1/users/{userId}/likes` | O | 내가 좋아요한 상품 목록 (페이징) |

**유스케이스: 좋아요 등록**

```
[Main Flow]
1. 로그인한 사용자가 상품에 좋아요를 요청한다
2. 시스템은 해당 상품의 존재 여부를 확인한다
3. 시스템은 이미 좋아요한 상태인지 확인한다
4. 좋아요를 저장하고 결과를 반환한다

[Exception Flow]
1-a. 비로그인 사용자 → 401 Unauthorized
2-a. 존재하지 않는 상품 → 404 Not Found
2-b. soft delete된 상품 → 404 Not Found (삭제된 상품에는 좋아요 불가)
3-a. 이미 좋아요한 상품 → 409 Conflict 또는 멱등하게 성공 처리

[후속 동작]
- 상품의 좋아요 수 갱신 (P12 결정에 따름)
```

**유스케이스: 좋아요 취소**

```
[Main Flow]
1. 로그인한 사용자가 상품 좋아요 취소를 요청한다
2. 시스템은 좋아요 존재 여부를 확인한다
3. 좋아요를 물리 삭제(hard delete)하고 결과를 반환한다

[Exception Flow]
1-a. 비로그인 사용자 → 401 Unauthorized
2-a. 좋아요하지 않은 상품에 대한 취소 → 404 Not Found 또는 멱등하게 성공 처리

[후속 동작]
- 상품의 좋아요 수 갱신 (P12 결정에 따름)

[참고: 좋아요 삭제 방식의 이원화]
- 사용자 직접 취소(이 유스케이스): 물리 삭제 — 사용자 의지에 의한 취소이므로 복구 대상이 아님
- 브랜드/상품 삭제로 인한 연쇄 삭제: soft delete(deletedAt 마킹) — 브랜드/상품 복구 시 함께 복원 가능
- 이 구분에 따라 Like 엔티티에 deletedAt 필드를 포함하되, 사용자 취소 시에는 레코드 자체를 제거함
```

**좋아요 목록 조회 쿼리 파라미터**

| 파라미터 | 타입 | 기본값 | 설명 |
|----------|------|--------|------|
| page | Int | 0 | 페이지 번호 |
| size | Int | 20 | 페이지당 항목 수 |

**유스케이스: 좋아요 목록 조회**

```
[Main Flow]
1. 로그인한 사용자가 자신의 좋아요 목록을 조회한다
2. 시스템은 해당 사용자가 좋아요한 상품 목록을 페이지네이션하여 반환한다

[Exception Flow]
1-a. 비로그인 사용자 → 401 Unauthorized

[고려사항]
- 다른 사용자의 좋아요 목록 조회 가능 여부 결정 필요
  (URI가 /users/{userId}이므로 타인 조회 가능성 존재)
- 삭제된 상품에 대한 좋아요는 목록에서 제외할지 여부
```

---

### 3.4 주문 (Order)

#### 대고객 API

| 기능 | METHOD | URI | 인증 | 설명 |
|------|--------|-----|------|------|
| 주문 요청 | POST | `/api/v1/orders` | O | 주문 생성 |
| 주문 목록 조회 | GET | `/api/v1/orders?startAt=...&endAt=...` | O | 기간별 주문 목록 |
| 주문 상세 조회 | GET | `/api/v1/orders/{orderId}` | O | 단일 주문 상세 |

**유스케이스: 주문 생성**

```
[Main Flow]
1. 로그인한 사용자가 주문할 상품 목록(상품 ID, 수량)을 전달하여 주문을 요청한다
2. 시스템은 각 상품의 존재 여부를 확인한다
3. 시스템은 각 상품의 재고를 확인한다
4. 시스템은 재고를 차감한다
5. 시스템은 주문 시점의 상품 정보를 스냅샷으로 저장한다
6. 시스템은 각 주문 항목의 (스냅샷 가격 × 수량)을 합산하여 totalAmount를 계산한다
7. 주문을 CREATED 상태로 생성하고 결과를 반환한다

[Exception Flow]
1-a. 비로그인 사용자 → 401 Unauthorized
1-b. 빈 상품 목록 → 400 Bad Request
1-c. 동일 상품이 중복 포함된 경우 → 400 Bad Request (동일 상품은 수량으로 표현해야 함)
1-d. 수량(quantity)이 1 미만인 항목 포함 → 400 Bad Request (수량은 1 이상의 양의 정수여야 함)
1-e. 수량(quantity)이 상한(P13)을 초과하는 항목 포함 → 400 Bad Request
2-a. 존재하지 않는 상품 포함 → 400 Bad Request
2-b. soft delete된 상품 포함 → 400 Bad Request (삭제된 상품은 주문 불가)
3-a. 재고 부족 상품 존재 → 409 Conflict (어떤 상품의 재고가 부족한지 명시)

[필수 요구사항]
- 상품 정보 스냅샷: 주문 시점의 상품명, 가격, 브랜드명 등을 주문 항목에 보관
- 재고 확인 및 차감: 재고 확인 → 차감이 원자적(atomic)으로 수행되어야 함
- 주문 총액 계산: totalAmount = Σ(각 OrderItem의 productPrice × quantity)
- 주문 초기 상태: 결제 미구현 현재 단계에서는 CREATED 상태로 생성

[후속 동작]
- 결제 연동은 추후 개발 예정 (결제 구현 시 CREATED → PAID 등의 상태 전이 추가)
```

**주문 목록 조회 쿼리 파라미터**

| 파라미터 | 타입 | 기본값 | 설명 |
|----------|------|--------|------|
| startAt | String | - | 조회 시작 날짜 (필수, yyyy-MM-dd) |
| endAt | String | - | 조회 종료 날짜 (필수, yyyy-MM-dd) |
| page | Int | 0 | 페이지 번호 |
| size | Int | 20 | 페이지당 항목 수 |

**유스케이스: 주문 목록 조회**

```
[Main Flow]
1. 로그인한 사용자가 기간(startAt, endAt)을 지정하여 주문 목록을 조회한다
2. 시스템은 해당 기간 내 사용자의 주문 목록을 요약 정보로 페이지네이션하여 반환한다
   (주문 ID, 주문 상태, 주문 총액, 주문 일시 등 — OrderItem 상세는 미포함)

[Exception Flow]
1-a. 비로그인 사용자 → 401 Unauthorized
1-b. startAt이 endAt보다 미래 → 400 Bad Request
1-c. 기간 미지정 시 → 400 Bad Request (P4 결정: 필수 파라미터)

[고려사항]
- 날짜 형식: yyyy-MM-dd (spec 예시 `startAt=2026-01-31&endAt=2026-02-10`에 근거하여 날짜만 사용으로 확정)
- 기간 제한: 최대 조회 가능 기간 정책 필요 여부
- 목록 조회와 상세 조회의 반환 범위 차이: 목록은 주문 건별 요약, 상세는 OrderItem(스냅샷) 포함

[참고]
- 페이지네이션(page, size)은 spec 원문에는 없는 자체 추가 사항임 (P5 결정에 의해 추가)
- 기간 내 주문이 대량일 경우 응답 크기 제어 및 어드민 API와의 일관성 확보 목적
```

**유스케이스: 주문 상세 조회**

```
[Main Flow]
1. 로그인한 사용자가 주문 ID로 주문 상세를 조회한다
2. 시스템은 주문 정보와 주문 항목(스냅샷 포함)을 반환한다

[Exception Flow]
1-a. 비로그인 사용자 → 401 Unauthorized
1-b. 존재하지 않는 주문 → 404 Not Found
1-c. 다른 사용자의 주문 조회 시도 → 403 Forbidden
```

#### 어드민 API

| 기능 | METHOD | URI | 인증 | 설명 |
|------|--------|-----|------|------|
| 주문 목록 조회 | GET | `/api-admin/v1/orders?page=0&size=20` | LDAP | 전체 주문 목록 (페이징) |
| 주문 상세 조회 | GET | `/api-admin/v1/orders/{orderId}` | LDAP | 단일 주문 상세 |

**유스케이스: 어드민 주문 목록 조회**

```
[Main Flow]
1. 어드민이 주문 목록을 요청한다 (페이징 포함)
2. 시스템은 전체 사용자의 주문 목록을 요약 정보로 페이지네이션하여 반환한다
   (주문 ID, 주문자 정보, 주문 상태, 주문 총액, 주문 일시 등 — OrderItem 상세는 미포함)

[Alternate Flow]
2-a. [향후 확장] 주문 상태, 기간, 사용자 등 필터 조건 추가 가능 (현재 spec에는 page/size만 명시)
2-b. 결과가 없는 경우 → 빈 목록 반환 (200 OK)
```

**유스케이스: 어드민 주문 상세 조회**

```
[Main Flow]
1. 어드민이 주문 ID로 주문 상세를 조회한다
2. 시스템은 주문 정보, 주문 항목(스냅샷 포함), 주문자 정보를 반환한다

[Exception Flow]
1-a. 존재하지 않는 주문 ID → 404 Not Found

[고려사항]
- 어드민은 모든 사용자의 주문을 조회할 수 있음 (대고객 API와 달리 본인 주문 제한 없음)
```

---

## 4. 애매한 요구사항 & 결정 필요 사항

> 아래는 요구사항 명세에서 명시되지 않았거나, 구현 시 결정이 필요한 항목들이다.

### 4.1 정책 질문

| # | 질문 | 영향 범위 | 선택지 |
|---|------|-----------|--------|
| P1 | 좋아요 중복 요청 시 어떻게 처리할 것인가? | Like API 응답 정책 | **A) 멱등하게 성공(200) 반환** - 클라이언트 구현이 단순해짐 / B) 409 Conflict 반환 - 명시적이지만 클라이언트에서 에러 핸들링 필요 |
| P2 | 좋아요 취소 시 이미 취소된 상태면? | Like API 응답 정책 | **A) 멱등하게 성공(200) 반환** / B) 404 Not Found 반환 |
| P3 | `/api/v1/users/{userId}/likes`에서 타인의 좋아요 목록 조회가 가능한가? | 인가 정책, API 설계 | A) 본인만 조회 가능 (userId 무시, 토큰 기반) / **B) 본인만 조회 가능하되, 요청 userId와 토큰 userId 불일치 시 403** / C) 누구나 조회 가능 |
| P4 | 주문 목록 조회 시 기간 미지정이면? | 주문 조회 API | A) 최근 3개월 기본 적용 / **B) 400 Bad Request로 필수 파라미터 요구** |
| P5 | 주문 목록 조회에 페이지네이션을 적용하는가? | 주문 조회 API | **A) 적용 (page, size 파라미터 추가)** - 기간 내 주문이 대량일 경우 응답 크기 제어 필수, 어드민 API와의 일관성 확보 / B) 미적용 (기간 필터로 충분) - 기간 제한이 충분히 짧다면 가능하나 대량 데이터 반환 위험 존재 |
| P6 | 삭제 방식은 soft delete인가 hard delete인가? | 전체 도메인 | **A) soft delete (deletedAt 필드)** - 데이터 복구 가능, 히스토리 보존 / B) hard delete - 단순하지만 복구 불가. 아래 도메인별 적용 범위 참조 |

> **P6 도메인별 soft delete 적용 범위:**
>
> | 엔티티 | soft delete 적용 | 이유 |
> |--------|:---:|------|
> | Brand | O | 복구 가능, 이력 관리 필요 |
> | Product | O | 복구 가능, 이력 관리 필요 |
> | Stock | X | Product에 종속. 별도 삭제 시나리오 없이 Product 삭제 시 함께 처리 |
> | Like | 조건부 | 사용자 직접 취소 → 물리 삭제 / 브랜드·상품 연쇄 삭제 → soft delete (복구 대비) |
> | Order | X | 주문은 삭제하지 않고 상태(status)로 관리 |
> | OrderItem | X | Order에 종속. 주문 삭제 시나리오 없음 |

| # | 질문 | 영향 범위 | 선택지 |
|---|------|-----------|--------|
| P7 | 브랜드/상품 삭제 시 해당 상품의 좋아요 데이터는? | Brand-Product-Like 연쇄, Product-Like 연쇄 | **A) 좋아요도 함께 soft delete** - 데이터 정합성 보장 / B) 좋아요는 유지하되 조회 시 필터링 - 사용자 히스토리 보존 |
| P8 | 주문 생성 시 동일 상품이 중복 포함되면? | Order API 입력 검증 | **A) 400 Bad Request로 거부** - 동일 상품은 수량으로 표현하도록 강제 / B) 서버에서 수량을 합산하여 처리 - 클라이언트 편의성 증가 / C) 별도 OrderItem으로 허용 - 유연하지만 데이터 중복 |
| P9 | 유효하지 않은 sort 파라미터 값이 들어오면? | Product 목록 조회 API | **A) 기본값(latest) 적용** - 클라이언트 구현이 단순, 관대한 처리 / B) 400 Bad Request 반환 - 명시적 에러로 잘못된 요청을 즉시 인지 가능 |
| P10 | 어드민 API에서 soft delete된 데이터를 조회할 수 있는가? | 어드민 전체 조회 API | **A) 조회 가능** - 삭제 이력 확인, 복구 등 관리 기능에 필요 / B) 조회 불가 - 대고객과 동일하게 삭제된 데이터 숨김 |
| P11 | soft delete된 엔티티에 대해 수정(PUT)/재삭제(DELETE) 요청이 오면? | 어드민 수정/삭제 API | **A) 404 Not Found 처리** - 삭제된 엔티티는 불변으로 취급, 복구 API를 별도 제공 / B) 수정/삭제 허용 - 삭제 상태에서도 관리 가능하게 허용 / C) 수정은 불가, 재삭제는 멱등하게 성공 |
| P12 | 좋아요 수 기반 정렬(likes_desc)을 위한 데이터 전략은? | Product 도메인 설계, 상품 목록 조회 쿼리 | **A) Product에 likeCount 비정규화 필드 유지** - 정렬 쿼리가 단순, 성능 유리. 좋아요 등록/취소 시 카운트 동기 갱신 / B) 매번 Like 테이블 count 조인 쿼리 - 항상 정확하지만 대량 데이터 시 성능 저하 |
| P13 | 주문 생성 시 개별 상품의 주문 수량 상한은? | Order API 입력 검증 | **A) 상한 설정 (예: 최대 999개)** - 비정상적 대량 주문 방지, 시스템 경계 입력 검증 / B) 재고 수량이 곧 상한 - 별도 제한 없이 재고가 허용하는 만큼 주문 가능 |

### 4.2 경계 질문

| # | 질문 | 영향 범위 | 선택지 |
|---|------|-----------|--------|
| B1 | 상품 스냅샷에 어떤 정보까지 저장하는가? | OrderItem 설계, 스토리지 | **A) 상품명, 가격, 브랜드명** - 주문 내역 표시에 필요한 최소 정보 / B) 상품 전체 정보 복사 - 확장성은 있으나 중복 데이터 증가 |
| B2 | 상품의 재고(stock)는 상품 엔티티의 속성인가, 별도 엔티티인가? | Product 도메인 설계 | A) Product 엔티티의 필드 - 단순하지만 동시성 제어 시 Product 전체 lock / **B) 별도 Stock 엔티티** - 재고 변경 시 Product lock 불필요, 동시성 제어 유리 |
| B3 | 고객 API와 어드민 API에서 노출하는 상품/브랜드 필드 차이는? | DTO 설계 | 어드민에게는 createdAt, updatedAt, deletedAt, 재고 수량 등 관리용 필드 추가 노출 / 고객에게는 이름, 가격, 브랜드 정보 등 표시용 필드만 노출 |
| B4 | 주문 생성 시 트랜잭션 경계는 어디까지인가? | Order 도메인, 트랜잭션 | **A) 재고 확인 + 차감 + 주문 생성을 하나의 트랜잭션** - 단순하고 정합성 보장, 트랜잭션 범위 넓음 / B) 재고 차감과 주문 생성을 분리 - 보상 트랜잭션 필요, 확장에 유리 |
| B5 | Like 엔티티의 식별자 전략은? | Like 테이블 설계, 유일성 보장 | A) (userId, productId) 복합키 - 별도 id 불필요, 유일성을 PK로 보장 / **B) 대리키(id) + (userId, productId) unique constraint** - JPA 매핑이 단순, 일관된 id 기반 설계 |

### 4.3 확장 질문

| # | 질문 | 현재 영향 | 향후 영향 |
|---|------|-----------|-----------|
| E1 | 결제 기능이 추가되면 주문 상태 흐름은 어떻게 되는가? | 주문 상태 필드를 미리 설계할지 여부 | 주문 상태: CREATED → PAID → SHIPPED → COMPLETED → CANCELLED 등의 상태 전이 필요 |
| ~~E2~~ | ~~좋아요 수 기반 정렬(likes_desc)의 성능 전략은?~~ | - | **P12로 격상됨** — likes_desc 정렬이 현재 구현 범위에 포함되므로 확장이 아닌 현재 결정 사항 |
| E3 | 주문 취소 기능이 추가될 경우 재고 복원은? | 재고 관리 정책 | 재고 차감의 역연산(복원) 로직 필요 |

---

## 5. 개념 모델

### 5.1 액터 정의

| 액터 | 설명 | 인증 방식 |
|------|------|-----------|
| 고객 (User) | 상품 조회, 좋아요, 주문을 수행하는 일반 사용자 | JWT 토큰 (user_required) |
| 어드민 (Admin) | 브랜드/상품/주문을 관리하는 운영자 | LDAP 인증 (ldap_required) |
| 비회원 (Guest) | 상품/브랜드 조회만 가능한 미인증 사용자 | 인증 없음 |

### 5.2 핵심 도메인 관계

```
[Brand] 1 ──── N [Product] 1 ──── 1 [Stock]
                      │
                      1
                      │
[User] 1 ──── N [Like] N ──── 1 [Product]  (User-Product 다대다를 Like 중간 엔티티로 해소)
   │
   1
   │
   N [Order] 1 ──── N [OrderItem] ──── 상품 스냅샷 포함
```

- **Brand - Product**: 1:N 관계. 브랜드 삭제 시 상품 연쇄 삭제
- **Product - Stock**: 1:1 관계. 재고를 별도로 분리하여 동시성 제어에 유리하도록 설계
- **User - Like - Product**: N:M 관계를 Like 중간 엔티티로 해소. (userId, productId)로 유일성 보장
- **User - Order - OrderItem**: 사용자는 여러 주문을 가지고, 주문은 여러 주문 항목을 포함. OrderItem에 주문 시점 상품 스냅샷 저장

### 5.3 도메인별 핵심 속성 (초안)

**Brand**
- id, name, description, createdAt, updatedAt, deletedAt

**Product**
- id, brandId, name, description, price, likeCount (비정규화, P12 결정에 따름), createdAt, updatedAt, deletedAt

**Stock**
- id, productId, quantity (≥ 0, 음수 불가), createdAt, updatedAt

**Like**
- id (대리키), userId, productId, createdAt, deletedAt (연쇄 삭제 시에만 사용, 사용자 취소 시에는 물리 삭제)
- 제약: (userId, productId) unique constraint으로 유일성 보장

**Order**
- id, userId, status (초기값: CREATED), totalAmount (= Σ OrderItem의 productPrice × quantity), orderedAt, createdAt, updatedAt

**OrderItem**
- id, orderId, productId, quantity, productName (스냅샷), productPrice (스냅샷), brandName (스냅샷)

---

## 6. 잠재 리스크

| # | 리스크 | 설명 | 완화 방안 |
|---|--------|------|-----------|
| R1 | 주문 생성 트랜잭션 비대화 | 재고 확인 + 차감 + 스냅샷 저장 + 주문 생성이 하나의 트랜잭션에 포함되면, 상품 수가 많을수록 트랜잭션 시간 증가 | 초기에는 단일 트랜잭션으로 구현하되, 성능 이슈 발생 시 재고 차감을 분리하는 방향으로 개선 |
| R2 | 재고 동시성 문제 | 동시 주문 시 재고 차감에서 race condition 발생 가능 | Stock 엔티티 분리 + 비관적 락(SELECT FOR UPDATE) 또는 낙관적 락(version 필드) 적용 |
| R3 | 좋아요 수 정합성 | P12에서 likeCount 비정규화를 채택할 경우, 실제 Like 레코드 수와 어긋날 수 있음 | 좋아요 등록/취소 시 동기적 갱신을 기본으로 하되, 장기적으로 주기적 배치 동기화 고려 |
| R4 | 브랜드 삭제 연쇄 영향 | 브랜드 삭제 시 대량 상품 + 좋아요의 연쇄 삭제로 인해 장시간 트랜잭션 발생 가능 | soft delete 적용 시 삭제 마킹만 수행하여 트랜잭션 부담 완화 |
| R5 | 스냅샷 데이터 증가 | 주문이 쌓일수록 스냅샷 데이터가 선형 증가 | 현 단계에서는 허용하되, 추후 아카이빙 전략 검토 |

---

## 7. 검증 책임 분리

> 검증을 어느 레이어에서 수행할지에 대한 원칙을 정리한다.

| 검증 위치 | 책임 범위 | 본 프로젝트 적용 |
|----------|----------|-----------------|
| **Controller** | 데이터 자체의 유효성 (null, 타입, 범위) → `@Valid` 활용 | 빈 상품 목록(400), quantity < 1(400), sort 파라미터 등 |
| **Application** | not found, 유효하지 않은 데이터 조회 요청 | 상품 미존재(404), 브랜드 미존재(404), soft delete된 엔티티 접근 |
| **Domain** | 비즈니스 규칙에 대한 검증 (핵심 불변식) | 재고 부족(409), likeCount ≥ 0, quantity ≥ 0 등 `init{}`/`guard()` |

- 위 분리 원칙은 유스케이스별 Exception Flow의 응답 코드 결정 근거가 됨
- 예: "빈 상품 목록 → 400"은 Controller 레벨 입력 검증, "재고 부족 → 409"는 Domain 비즈니스 규칙 검증

---

## 8. 문서화 원칙

> 설계 문서의 작성/유지 원칙을 정리한다.

| 원칙 | 본 프로젝트 적용 |
|------|-----------------|
| **Why > How** | Section 4(결정 필요 사항)에 "어떤 대안을 검토했고 어떤 근거로 결정했는지"를 기록. How(비즈니스 로직)를 넣으면 갱신이 끝없으므로 Why(결정 근거)를 중심으로 문서화 |
| **트레이드오프 기록** | 각 정책 결정(P1~P13)에 선택지별 장단점을 명시하여, 피드백 시 설계 의도를 확인 가능하도록 함 |
| **설계 추상화 단계** | Requirements(What) → Sequence(흐름) → Class(책임) → ERD(저장). 본 문서는 가장 높은 추상화 수준을 유지 |

---

## 9. API 전체 요약

### 대고객 API (`/api/v1`)

| 도메인 | METHOD | URI | 인증 | 설명 |
|--------|--------|-----|------|------|
| Brand | GET | `/api/v1/brands/{brandId}` | X | 브랜드 정보 조회 |
| Product | GET | `/api/v1/products` | X | 상품 목록 조회 (필터/정렬/페이징) |
| Product | GET | `/api/v1/products/{productId}` | X | 상품 상세 조회 |
| Like | POST | `/api/v1/products/{productId}/likes` | O | 좋아요 등록 |
| Like | DELETE | `/api/v1/products/{productId}/likes` | O | 좋아요 취소 |
| Like | GET | `/api/v1/users/{userId}/likes` | O | 좋아요한 상품 목록 |
| Order | POST | `/api/v1/orders` | O | 주문 생성 |
| Order | GET | `/api/v1/orders?startAt=...&endAt=...` | O | 주문 목록 조회 (기간) |
| Order | GET | `/api/v1/orders/{orderId}` | O | 주문 상세 조회 |

### 어드민 API (`/api-admin/v1`)

| 도메인 | METHOD | URI | 인증 | 설명 |
|--------|--------|-----|------|------|
| Brand | GET | `/api-admin/v1/brands` | LDAP | 브랜드 목록 조회 |
| Brand | GET | `/api-admin/v1/brands/{brandId}` | LDAP | 브랜드 상세 조회 |
| Brand | POST | `/api-admin/v1/brands` | LDAP | 브랜드 등록 |
| Brand | PUT | `/api-admin/v1/brands/{brandId}` | LDAP | 브랜드 수정 |
| Brand | DELETE | `/api-admin/v1/brands/{brandId}` | LDAP | 브랜드 삭제 |
| Product | GET | `/api-admin/v1/products` | LDAP | 상품 목록 조회 |
| Product | GET | `/api-admin/v1/products/{productId}` | LDAP | 상품 상세 조회 |
| Product | POST | `/api-admin/v1/products` | LDAP | 상품 등록 |
| Product | PUT | `/api-admin/v1/products/{productId}` | LDAP | 상품 수정 |
| Product | DELETE | `/api-admin/v1/products/{productId}` | LDAP | 상품 삭제 |
| Order | GET | `/api-admin/v1/orders` | LDAP | 주문 목록 조회 |
| Order | GET | `/api-admin/v1/orders/{orderId}` | LDAP | 주문 상세 조회 |
